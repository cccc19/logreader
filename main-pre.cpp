#include<iostream>
#include<fstream>
#include<string>
#include<filesystem>
#include<algorithm>
#include<sys/stat.h>
#include"logReader.h"


logReader myReader;                             //create a logReader object
std::string baseDir = myReader.getBaseDir();    // get the base directory


int getResults(std::string filename);
void getDirList(std::string searchDate);

int main()
{
    std::string searchDate;
    myReader.setMacInfo(0,"","");    // Call myReader to set up machine names.. TODO fix this to use a setup file..
    //enter main loop keep giong until user types 'q'
    do
    {
    
    std::cout << "\nEnter the date in the exact format yyyy-mm-dd  'q' to end: ";
    std::cin >> searchDate;
    
    if(searchDate == "q")
        break;

    getDirList(searchDate);
    } while(searchDate != "q");

    return 0;
}

void getDirList(std::string searchDate)
{
    std::string str = "H19";
    std::string str2 = searchDate;
    
    std::string str3 = "GeometryCheckTemplate6x";

    
    std::size_t found;
   
    std::filesystem::path pathToShow(baseDir);  //create object of type path and pass basepath to its constructor
    
    std::string line[11350];   // Create enough storage for all rows generated by search
    
    std::cout << "exists() = " << std::filesystem::exists(pathToShow) << '\n'
              << "root_path = " << pathToShow.root_path() << '\n'
              << "reletive_path = " << pathToShow.relative_path() << '\n'
              << "perent_path = " << pathToShow.parent_path() << '\n';
              int i = 1;
            //   for (const auto& part : pathToShow)
            //     std::cout << "path part: " << i++ << " = " << part <<'\n';

    std::filesystem::directory_iterator dirToShow(baseDir);  // create directory object using basePath
    i = 0;
    
    for (const auto& part : dirToShow) // get each element (directory) and stick it in 'part' which has type path(). Run through full list from directory
    {
        
        line[i] = part.path().string();  //convert path type to a sting type and stick it in array line[]. 
        //std::cout << i++ << " : " << part.path().string() << '\n';
        //std::cout << i << " : " << line[i] << '\n';  // print i, print print directory from line[] array
                                                        
        found = line[i].find(str);
        if (found!=std::string::npos)
        {
            //std::cout << i << " : " << line[i] << std::endl;
            line[i].append("/MPCChecks");
            std::filesystem::directory_iterator dirSub1ToShow(line[i]);  // create directory object using basePath
            //std::string linesub1[sizeof(dirSub1ToShow)];
            std::string linesub1[11350];
            int j = 0;
            for (const auto& part1 : dirSub1ToShow) // get each element (directory) and stick it in 'part1' which has type path().
            {
                linesub1[j] = part1.path().string();
                found = linesub1[j].find(str2);
                if (found!=std::string::npos)
                {                    
                    found = linesub1[j].find(str3);
                    if (found!=std::string::npos)
                    {
                        std::string filename = linesub1[j] += "\\Results.csv";
                        
                        // std::cout << j << " : " << linesub1[j] << std::endl;
                        //std::cout << j << " : " << filename << std::endl;
                        if(std::filesystem::exists(filename))
                        {
                            //std::cout << "\nMPC Check\n";
                            // for (size_t i = 0; i < 10; i++)
                            // {
                            //     if(filename.find(myReader.getMachSer(i)))
                            //         std::cout << myReader.getMachSer(i) << std::endl;  //test print can be removed
                            // }
                            

                            //std::cout << myReader.getMachSer(0) << std::endl;  //test print can be removed

                            getResults(filename);
                            //std::cout << "MPC Check END\n\n";
                        }
                        
                        j++;
                    }
                }
            }
    
        }
        i++;
    }  
   
}


int getResults(std::string filename)
{
    std::string line;
    std::string str = "Leaf";
    std::string str2 = "Marginal";
    std::string str3 = "CollimationGroup/MLCBacklashGroup/MLCBacklash";
    std::string str4 = "/MLCBacklash";

    
    std::replace(filename.begin(),filename.end(),'/','\\');   // Fixes Slashes in file name so they all point correct way for MicroSoft.. and add escape for c++ strings
    
    std::cout << filename << "\n\n";
  
    std::ifstream infile;
    std::size_t found;

    infile.open(filename);
    if (!infile)
    {
        std::cout << "\nUnable to open file\nor No file found for this MPC check\n\n";
        
        return 1;
    }

    
    std::cout << "Leaves with poor backlash: \n\n";

    while (!infile.eof() )
    {
        std::getline(infile, line);
        found = line.find(str);
        if (found!=std::string::npos){
            found = line.find(str2);
            if (found!=std::string::npos){
                std::cout << "\nMPC Check\n";
                
                line.replace(line.find(str3),str3.length(),"");  //Tidy up the output
                line.replace(line.find(str4),str4.length()," "); //Tidy up the output
                std::cout << line << '\n';
                std::cout << "MPC Check END\n\n";
            }
        }

    }
    return 0;
}

